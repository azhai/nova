#!/bin/sh
# Run each test and compare
# against known good output

EXE="$1"

# Build our compiler if needed
if [ ! -f "$EXE" ]
then (cd ../n1c; make)
fi

mkdir -p ssa/

# Try to use each input source file
for n in $(seq -f "%03g" 35 38)
# We can't do anything if there's no file to test against
do
  i="test$n.al"
  j="test$n.txt"
  k="ssa/test$n.q"
  if [ ! -f "out/$j" -a ! -f "err/$j" ]
   then echo "Can't run test on $i, no output or error file!"; exit 1

   # Output file: compile the source, run it and
   # capture the output, and compare it against
   # the known-good output
   else if [ -f "out/$j" ]
        then
	  # Print the test name, compile it with our compiler
          echo -n $i
	  $EXE -o $k $i && qbe $k > out.s && cc -o bin out.s
          ./bin > trial

  	  # Compare this agains the correct output
          cmp -s "out/$j" trial

	  # If different, announce failure
          # and print out the difference
          if [ "$?" -eq "1" ]
          then echo ": failed"
            diff -c "out/$j" trial
	    # Stop if our 1st argument is "stop"
	    if [ "$#" -eq 1 ] && [ $1 = "stop" ]
	    then exit 1
	    fi
            echo

	  # No failure, so announce success
          else echo ": OK"
          fi

   # Error file: compile the source and
   # capture the error messages. Compare
   # against the known-bad output. Same
   # mechanism as before
   else if [ -f "err/$j" ]
        then
          echo -n $i
	  $EXE -o /dev/null $i 2> trial
          cmp -s "err/$j" trial
          if [ "$?" -eq "1" ]
          then echo ": failed"
            diff -c "err/$j" trial
            echo
          else echo ": OK"
          fi
        fi
     fi
   fi
   rm -f bin out.[qs] trial
done
